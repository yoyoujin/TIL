# Socket.IO

## 💡 Socket.io 기본개념

1. Socket: 소켓은 클라이언트와 서버 간의 연결을 나타낸다. 소켓을 사용하여 실시간으로 데이터를 보내고 받을 수 있다.
2. Server: 서버는 클라이언트와의 소켓 연결을 설정하고 관리한다. 서버는 클라이언트로 이벤트를 방출하거나 클라이언트로부터 이벤트를 수신할 수 있다.
3. Client: 클라이언트는 서버와의 소켓 연결을 설정하고 관리한다. 클라이언트는 서버와 동일하게, 서버로 이벤트를 방출하거나 서버에서 이벤트를 수신할 수 있다.

## 💡 Socket.io 트래픽 격리 구분

1. Event: 이벤트는 소켓 연결을 통해 클라이언트-서버 간의 전송된 메세지이다. 이름은 서버와 클라이언트에서 동일하게 선언해야한다. (JSON, 문자열, 이진 등 모든 형식의 데이터 포함 가능)
2. Namespace: 네임 스페이스는 클라이언트-서버 간의 별도의 통신 채널이다. 단일 서버에서 여러 네임 스페이스를 작성할 수 있으며 클라이언트는 특정 네임 스페이스에 연결하여 해당 네임 스페이스의 다른 클라이언트에게만 이벤트를 수신하거나 방출할 수 있다.
3. Room: 룸은 함께 결합 된 소켓 그룹이다. 소켓은 여러 룸에 합류하거나 떠날 수 있다. 룸은 연결된 모든 고객에게 방송하는 대신 특정 클라이언트 그룹에 메세지를 보내는 데 유용하다.

## 💡 Socket.io 이벤트 송수신 방식

1. Public: Public은 연결된 모든 클라이언트에게 메세지가 전송되는 경우이다. 채팅 메시지와 같은 일반 메시지를 연결된 모든 클라이언트에게 보내는 데 유용하다.
2. Private: 특정 고객에게 메시지를 보낼 때. 알림 또는 개인 메시지를 특정 클라이언트로 보내는 데 유용
3. Broadcasting: 발신제를 제외한 모든 클라이언트에게 메시지가 전송되는 경우.

## 💡 Socket.io 이벤트 송수신 개념

1. Emit: 클라이언트 <-> 서버 간의 이벤트를 보내는 데 사용. 두 개 이상의 인수가 필요 (이벤트이름, 보낼데이터)

```js
// (A: 이벤트이름, B: 전송될 데이터)
socket.emit('chat message', 'Hello, world!');
```

2. To: 특정 소켓이나 방에 이벤트를 방출하는 데 사용. 하나의 인수 필요 (이벤트가 전송될 소켓ID)

```js
// to 메소드는 이벤트를 보낼 소켓 ID를 지정하는 데 사용
io.to('12345').emit('chat message', 'Hello, world!');
```

3. On: 클라이언트 또는 서버에서 이벤트에 대한 리스너를 등록하는데 사용. 두 개 이상의 인수 필요(이벤트이름, 콜백함수)

```js
// (A: 이벤트이름, B: 이벤트가 수신될 때 호출하는 콜백함수-데이터)
socket.on('chat message', (message) => {
  console.log(`Received message: ${message}`);
});
```

4. Of: 자체 소켓 및 이벤트 세트로 새 네임 스페이스를 만드는 데 사용. 하나의 인수 필요(네임 스페이스의 이름)

```js
// of 메소드는 새로운 네임스페이스를 만드는 데 사용
const chatNamespace = io.of('./chat');
```

## 👉 Socket.io 작동방식

Socket.IO는 클라이언트-서버 간의 WebSocket 연결을 설정하여 작동한다.

- 서버는 들어오는 연결을 확인하고 클라이언트가 방출하는 이벤트를 처리한다. 클라이언트는 서버에 연결하고 이벤트를 방출하거나 이벤트를 확인할 수 있다. 클라이언트가 이벤트를 방출하면 서버는 이벤트를 수신하여 클라이언트로 응답을 다시 보내거나 동일한 네임스페이스 또는 방에 있는 다른 클라이언트로 이벤트를 브로드캐스트 할 수 있다.

## 👉 Socket.IO - client

### 1. 설치

```js
npm install socket.io-client
```

### 2. The Socket instance (client-side)

소켓이 현재 서버와 연결되어있는지 여부

```js
socket.on('connect', () => {
  console.log(socket.connected); // true
});
socket.on('disconnect', () => {
  console.log(socket.connected); // false
});
```
