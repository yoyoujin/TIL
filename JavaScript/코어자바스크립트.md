# 코어 자바스크립트 TIL

## 실행 컨텍스트

### Intro

- 실행 컨텍스트는 **실행할 코드에 제공할 환경 정보들을 모아둔 객체**
- 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고 (호이스팅), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행한다.<br>
  -> 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생함
- 자바스크립트에서 가장 중요한 핵심 개념 중 하나이다.

### 01. 실행 컨텍스트란?

- 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성
- 이를 콜스택(call stack)에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련있는 코드들을 실행하는식으로 전체 코드의 환경과 순서를 보장한다.
- 동일한 환경: 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, 함수 등이 있다.
- 자동으로 생성되는 전역공간과 악마로 취급받는eval 을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 '함수를 실행하는 것'이다.

<br>

💡 활성화된 실행 컨텍스트에 담기는 정보들

1. VariableEnvironment

- 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 렉시컬 환경의 스냅샷으로 변경사항은 반영되지 않음

2. LexicalEnvironment

- 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영됨.

3. ThisBinding: this 식별자가 바라봐야할 대상 객체

### 02. VariableEnvironment

- VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행시 스냅샷을 유지한다는 점이 다르다.
- 실행 컨텍스트 생성 시 -> VariableEnvironment에 정보를 담음 -> 그대로 복사해서 LexicalEnvironment에 정보를 만들고 주로 활용
- 구성내용 : environmentRecord, outerEnvironment

### 03. LexicalEnvironment

👉 environmentRecord와 호이스팅

- environmentRecord에는 현재 컨텍스트와 관련된 `코드의 식별자 정보`들이 저장된다.
  (따라서 실행 컨텍스트가 관여하는 코드들이 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명을 모두 알고있게 되는 것이다!)

- 호이스팅 규칙
  - environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다.

```js
// 매개변수와 변수에 대한 호이스팅(1) - 원본코드
function a(x) {
  // 수집대상1 - 매개변수
  console.log(x); // (1)
  var x; // 수집대상2 - 변수선언
  console.log(x); // (2)
  var x = 2; // 수집대상3 - 변수선언
  console.log(x); // (3)
}
a(1);
```

```js
// 매개변수와 변수에 대한 호이스팅(2) - 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태이다.
function a(x) {
  var x = 1; // 수집대상1 - 매개변수 선언)
  console.log(x); // (1)
  var x; // 수집대상2 - 변수선언
  console.log(x); // (2)
  var x = 2; // 수집대상3 - 변수선언
  console.log(x); // (3)
}
a();
```

- 변수 정보를 수집하는 과정인 호이스팅 처리
- environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지에는 관심이 없다!
  👉 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래의 자리에 남겨둔다!

```js
// 매개변수와 변수에 대한 호이스팅(3) - 호이스팅을 마친 상태
function a(x) {
  var x; // 수집대상1의 변수선언
  var x; // 수집대상2의 변수선언
  var x; // 수집대상3의 변수선언

  x = 1; // 수집대상1의 할당
  console.log(x); // (1)
  console.log(x); // (2)
  x = 2; // 수집대상 3의 할당
  console.log(x); // (3)
}
a(1);
```

코드 실행 순서

- 수집대상1의 변수선언
  - 변수 x를 선언한다. 이때 메모리에서는 저장할 공간을 미리 확보, 확보한 공간의 주솟값을 변수 x에 연결해둔다.
- 수집대상2, 수집대상3의 변수선언
  - 다시 변수 x를 선언한다. 이미 선언된 변수 x가 있으므로 무시한다.
- 수집대상 1의 할당
  - 숫자 1을 별도의 메모리에 담는다. x와 연결된 메모리 공간에 숫자 1을 가리키는 주솟값을 연결한다.
- (1), (2)
  - 각 x를 출력 -> 모두 숫자1이 출력된다.
- 수집대상 3의 할당
  - 숫자 2를 별도의 메모리에담고, 그 주솟값을 든 채로 x와 연결된 메모리 공간으로 간다. 여기에는 숫자 1을 가리키는 주솟값이 들어있었는데, 이걸 2의 주솟값으로 대치한다.
- (3)
  - 숫자 2가 출력된다.
- 함수 내부의 모든 코드가 실행되어, 실행 컨텍스트가 콜스택에서 제거된다.
  <br><br>

### 함수 선언문과 함수 표현식

- 함수 선언문: function 정의부만 존재, 별도의 할당 명령이 없는 것을 의미 -> `함수명`이 반드시 정의돼있어야함!
- 함수 표현식: 정의한 function을 별도의 변수에 할당하는 것을 의미

```js
// 함수를 정의하는 세가지 방식
function a() {}
// 함수 선언문: 함수명 a가 곧 변수명

var b = function () {};
// (익명) 함수 표현식. 변수명 b가 곧 함수명

var c = function d() {};
// 기명 함수 표현식. 변수명은 c, 함수명은 d
c(); // 실행 ok
d(); // Error
```

```js
// 함수 선언문과 함수 표현식(1) - 원본코드
console.log(sum(1, 2));
console.log(multiply(3, 4));

function sum(a, b) {
  // 함수선언문 sum
  return a + b;
}

var multiply = function (a, b) {
  // 함수표현식 multiply
  return a * b;
};
```

```js
// 함수 선언문과 함수 표현식(2) - 호이스팅 후
var sum = function sum(a, b) {
  return a + b;
};
// ** 함수선언문은 전체를 호이스팅 해버린다 !

var multiply; // 변수는 선언부만 끌어올린다.

console.log(sum(1, 2)); // 3
console.log(multiply(3, 4)); // 'not a function'

multiply = function (a, b) {
  return a * b;
};
// 변수의 할당부는 원래 자리에 남겨둔다.
```

💡 함수 선언문의 위험성

- sum 함수는 선언 전에 호출해도 아무 문제 없이 실행된다.
- 어떻게 작성해도 오류를 내지 않는다는 면에서 접근이 쉬워 보이는 측면도 있으나, 큰 혼란을 일으키는 원인이 되기도 한다.
- ex. 개발자 A가 sum 함수를 선언한다. (두 인자의 합을 반환하는 함수) <br>
  이 함수는 거대한 자바스크립트 파일 내의 100번째 줄에 위치한다. <br>
  어느날 개발자 B가 sum 함수를 같은 파일의 5000번째 줄에서 새로 선언한다.
  (문자열로 'x + y = (x+y)'를 반환하는 함수) <br>
  👉 컨텍스트가 활성화될 때 선언된 함수들이 모두 가장 위로 끌어올려지면서 나중에 할당한 값이 먼저 할당한 값을 덮어 씌운다(override).
- A의 의도와는 다르게 문자열을 반환하는 함수가 실행된다. 여기 저기서 문제가 생기고 있는데 정작 문제 원인인 sum 함수는 전혀 에러를 내뿜지 않는다.
  👉 만약 A,B 모두 함수 표현식으로 정의했다면 함수들은 모두 의도대로 동작했을 것이고, 에러가 검출되므로 더욱 빠른 타이밍에 손쉽게 디버깅할 수 있을 것이다.

결론: 상대적으로 함수 표현식이 안전하다 !!
<br><br>

### 스코프, 스코프 체인, outerEnvironmentReference

- 스코프란 식별자에 대한 유효범위이다.
- 식별자의 유효범위를 안부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다.
- LexicalEnvironment의 두번째 수집 자료인 outerEnvironmentReference가 이를 가능하게 한다.

💡 스코프 체인

- outerEnvironment는 현재 호출된 함수가 선언될 당시의 LexicalEnvironmentfmf 참조한다.
- '선언될 당시': 과거시점, 콜스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 뿐이다.
- 함수를 선언(정의)하는 행위 자체도 하나의 코드에 지나치지 않으며, 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행된다.

![image](https://github.com/yoyoujin/Programmers/assets/102464638/3516dc31-8f90-4a8e-a4a3-a0bed1a19469)
