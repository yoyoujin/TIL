# JavaScript 정리

## 자바스크립트의 특징

- 객체 기반의 스크립트 언어
- 동적타입, 타입을 명시할 필요가 없는 인터프리어 언어이기때문에 프로그램을 실행하는 도중에 변수에 저장되는 데이터 타입이 동적으로 바뀔 수 있음
- 프로토타입이라는 개념을 통해 객체지향 언어들의 특징을 구현한다. 따라서 자바스크립트는 클래스 기반이 아닌 프로토타입 기반의 객체 지향 언어이다.
- 객체 지향형 프로그래밍 / 함수형 프로그래밍 모두 표현 가능

## 일급객체

- 프로그래밍에서 일반적으로 다른 객체들에 적용가능한 연산을 모두 지원하는 객체이다.
- 함수를 값으로도 저장할 수 있고, 파라미터로 넣어줄 수 있고, 리턴 값으로도 쓰일 수가 있는 것이 일급객체이다.
- 자바스크립트의 함수가 이에 해당한다.
- 일급객체의 조건
  1. 변수에 담을 수 있다.
  2. 인자로 전달할 수 있다.
  3. 반환 값으로 사용할 수 있다.

## 고차함수

고차함수는 함수를 '값'으로 다루는 함수이다. 보통 2가지 종류가 있다.

- 함수를 인자로 받아서 실행
- 함수를 만들어 리턴 (클로저 함수를 만들어 리턴하는 함수)

## 콜백함수

- 자바스크립트의 함수는 일급객체이다. 따라서 함수에 파라미터로 함수를 전달 할 수 있다.
- 이때 파라미터로 전달되는 함수, 함수의 내부에서 실행되는 함수를 콜백함수라 한다.

## var, let, const

1. var

- 함수 레벨 스코프
- 함수레벨 스코프는 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.
  즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

2. let, const

- 블록 레벨 스코프
- 블록 레벨 스코프는 코드블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드블록 외부에서는 참조할 수 없다.
  즉, 코드 블록 내부에서 선언한 변수는 지역변수이며 블록 외부에서 선언한 변수는 전역변수이다.

👉 var, let은 변수 선언시 초기 값을 주지 않아도 되지만 const는 반드시 초기 값을 할당해야한다.
👉 var, let은 재할당이 가능하지만 const는 재할당이 불가능하다.

## 호이스팅

- 자바스크립트에서 호이스팅이란, 자바스크립트 엔진이 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다.
- 코드가 실행하기 전 `변수선언/함수선언` 이 해당 스코프의 최상단으로 끌어 올려지는 것 같은 현상을 말한다.
  - 자바스크립트 엔진은 소스 코드를 한 줄씩 순차적으로 실행(런타임)에 앞서 먼저 소스 코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비 (실행 컨텍스트를 위한 과정)를 한다.
    `소스코드 평가 -> 실행(런타임)`
  - 위 과정에서 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 실행한다.
  - 변수 선언은 코드가 순차적으로 실행되는 런타임 이전에 먼저 실행되지만 변수 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
  - 따라서 코드 실행 전 이미 변수/함수 선언이 되었기 때문에 선언문보다 참조/호출이 먼저 나와도 오류없이 동작한다. (정확히는 var와 함수 선언문만 해당)
- var, let, const, function, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. 선언문은 런타임 이전에 먼저 실행되기 때문에!
- var로 선언한 변수의 경우 호이스팅 시 undefined로 변수를 초기화한다.
  반면 let과 const로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않는다.
  블록스코프의 최상단으로 호이스팅되어 선언만 되고, 값이 할당되기 전까지 어떤 값으로도 초기화되지 않는다. 따라서 var로 선언한 변수는 선언 전에 사용해도 에러가 나지 않지만, let과 const는 ReferenceError가 발생한다.

## 함수선언문 vs 함수표현식

- 문법적 차이
  - 함수선언문 : function 함수이름(){}
  - 함수표현식 : const func = function(){}
- 자바스크립트 엔진이 함수를 생성하는 시점
  - 함수선언문은 실제 실행 흐름이 함수 선언문이 정의된 부분에 도달하기 전에도 함수를 호출할 수 있다. (호이스팅의 영향!)
  - 함수표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 호출할 수 있다.

## 화살표 함수

- 화살표 함수는 항상 익명함수이다.
- 따라서 함수를 호출하기 위해 함수표현식을 써야한다!
- 일반 함수는 this를 바인딩할 객체가 동적으로 결정되는 반면,
  화살표 함수의 thi는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는데
  일반함수와 다르게 언제나 상위 스코프의 this를 가리킨다.
  이를 `렉시컬 this` 라고 한다.
- 화살표 함수는 생성자 함수로 사용할 수 없다.
  prototype 프로퍼티를 가지고 있지 않기 때문에

## 렉시컬 스코프

- 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라, 어디서 선언하였는지에 따라 결정된다.
- 선언한 시점에 상위 스코프가 결정된다. 어디서 호출하였는지는 스코프 결정에 아무런 영향도 주지 않는다.
  - 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정 -> 렉시컬스코프
  - 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정 -> 동적 스코프

## 자바스크립트 엔진

- 자바스크립트 엔진은 `Memory Heap`과 `Call Stack`으로 구성되어있다.
- 자바스크립트는 단일스레드인데, 이 의미는 Call Stack이 하나라는 것이다.
  - Memory Heap : 메모리 할당이 일어나는 곳 (우리가 선언한 변수, 함수 등이 담겨져 있음)
  - Call Stack : 코드가 실행될 때 쌓이는 곳 (Stack 형태로 쌓인다.)
- 단일 콜스택을 갖는다는 것 ? : 요청이 동기적으로 처리된다는 것을 의미
- 비동기 요청을 처리하기 위해서는 자바스크립트를 실행하는 환경인 브라우저나 Node.js가 담당한다.

## Web API

- Web API는 JS Engine이 아니다.
- Web API는 브라우저에서 제공하는 API로, DOM, AJAX, Timeout등이 있다.
- Call Stack에서 실행된 비동기 함수는 Web API를 호출하고, Web API는 콜백함수를 Callback Queue에 넣는다.

## 이벤트 루프

- 자바스크립트는 싱글스레드기반 언어이다. 따라서 한번에 하나의 함수만 처리할 수 있다. 하지만 자바스크립트에서는 `이벤트 루프`에 기반한 `동시성 모델`을 지원한다.
- 이벤트 루프는 콜스택과 콜백큐의 상태를 체크하며 콜스택이 빈 상태가 되면 콜백큐의 첫번째 콜백함수를 콜스택에 넣는다. 이러한 행위를 반복하기 때문에 루프라고 한다. 또한 이러한 반복적인 행동은 틱(Tick)이라고 부른다.
- 과정
  1. 자바스크립트 코드가 실행되고 함수가 호출되면, 호출된 함수는 CallStack에 쌓인다.
  2. Stack의 후입선출의 룰에 따라 제일 마지막에 들어온 함수가 먼저 실행되며, 실행된 함수는 CallStack에서 제거된다. Stack에 쌓여진 함수가 모두 실행된다.
  3. 만약 setTimeout과 같은 비동기 함수가 실행된다면, Web API가 호출되고 Call Stack에서 제거된다.
  4. 타이머가 종료되면 setTimeout의 콜백함수를 CallBack Queue에 넣는다.
  5. 이벤트루프는 콜스택이 빈 상태가되면 콜백큐에 있는 첫번째 콜백을 콜스택으로 이동시킨다.

## Callback Queue

- Callback Queue에는 Task Queue와 Microtask Queue가 있다.
- 이벤트루프는 우선적으로 microtaskqueue를 확인한다. 만약 콜백이 있다면 먼저 callstack에 담고, 처리해야할 콜백함수가 없다면 taskqueue를 확인 후 처리한다.
- Task Queue
  - setTimeout()
  - setInterval()
  - UI렌더링
  - requestAnimationFrame()
- Microtask Queue
  - Promise(then)
  - MutationObserver

## 실행컨텍스트

```js
var a = 1; // 전역 컨텍스트
function outer() {
  // outer 컨텍스트
  function inner() {
    // inner 컨텍스트
    console.log(a); // undefined
    var a = 3;
    console.log(a); // 3
  }
  inner();
  console.log(a); // 1
}
outer();
console.log(a); //1
```

프로그램 실행 : 전역컨텍스트
outer 실행 : 전역컨텍스트, outer
inner 실행 : 전역컨텍스트, outer, inner
inner 종료 : 전역컨텍스트, outer
outer 종료 : 전역컨텍스트
프로그램 종료 :

- 실행컨텍스트는 자바스크립트 코드 실행 환경에 대한 여러가지 정보를 담고있는 개념
- 실행컨텍스트는 전역컨텍스트, 함수컨텍스트 2가지 종류가 있다.
- 처음 자바스크립트 코드를 실행하는 순간 모든 것을 포함한 전역컨텍스트가 생기고 실행 컨텍스트에 쌓인다.
- 전역컨텍스트 생성 후에 `함수 컨텍스트는 함수를 호출할 때 실행컨텍스트에 쌓이고` 끝나면 제거된다.
- 컨텍스트 생성시에는 변수 객체(arguments, variable), 함수선언, scope chain, this가 생성된다.
- 컨텍스트 생성 후에 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없으면 스코프 체인을 따라 올라가며 찾는다.
- 함수 실행이 마무리되면 해당 컨텍스트는 제거된다. (단, 클로저 제외)
  모든 코드가 종료되면 전역 컨텍스트는 제거된다.

## 클로저

```js
const closure = () => {
  let count = 0;
  return function () {
    count++;
    return count;
  };
};

let temp = closure();
console.log(temp()); // 1
console.log(temp()); // 2
console.log(temp()); // 3
```

- 클로저는 반환되는 내부함수가 자신이 선언되었을 때의 렉시컬 스코프를 기억하여, 자신이 선언되었을 때 스코프 밖에서 호출되어도 선언되었을때의 렉시컬 스코프에 접근할 수 있는 함수.

- 클로저를 생성하는 가장 일반적인 방법은 함수 내부에서 함수를 정의하고 반환하는 것입니다. 이때 내부 함수는 외부 함수의 변수를 참조하고, 이 변수는 내부 함수가 반환된 이후에도 메모리에 유지됩니다.

클로저는 아래와 같은 상황에서 사용됩니다.

- 함수 내부에서 함수를 정의하고 반환하는 경우
- 객체 내부에서 함수를 정의하고 반환하는 경우
- setTimeout(), setInterval()과 같은 함수에서 콜백 함수를 정의하는 경우

클로저를 사용하면 자바스크립트에서 매우 유용한 기능을 구현할 수 있습니다. 예를 들면, 개인정보와 같은 중요한 정보를 안전하게 보호하기 위해 클로저를 사용한 데이터 은닉(data encapsulation) 기능을 구현할 수 있습니다.

## this 바인딩

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기참조변수이다.
- 자바스크립트 함수, 콜백함수의 this는 어디에 선언되어있든 간에 전역객체를 바인딩한다.
  - 브라우저에서는 window이며, node환경에서는 global
  - 단, 엄격모드에서는 undefined를 반환
- 객체 메서드 내부의 this는 해당 메서드를 호출한 객체에 바인딩된다.
- 화살표 함수의 this는 언제나 자신이 선언되었을때의 상위 스코프의 this (이를 렉시컬 this라고 함)

## 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임

- 이벤트 버블링(기본)
  - 하위 엘리먼트에 이벤트가 발생할 때, 그 엘리먼트로부터 시작해서 상위 요소까지 이벤트가 전달되는 방식 (하 -> 상)
- 이벤트 캡쳐링
  - 하위 엘리먼트에 이벤트 핸들러가 있을 때, 상위 엘리먼트로부터 이벤트가 발생하기 시작하여 하위 엘리먼트까지 이벤트가 전달되는 방식 (상 -> 하)
- 자바스크립트 코드에서 기본 동작은 이벤트 버블링이다.
- 이벤트 위임
  - 여러 요소를 다뤄야할 때 주로 사용
  - 하위 엘리먼트들이 여러 개 있을 때, 하위 엘리먼트들에 각각 이벤트 핸들러를 달지 않고 상위 엘리먼트에 이벤트 핸들러를 달아 하위 엘리먼트들을 제어하는 방식

## AJAX

- Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)
- 자바스크립트 라이브러리중 하나로, 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 변경하기 위한 데이터 로드 기법
- 자바스크립트를 통해 서버-브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능

## Fetch

- ES6부터 도입된 fetch를 사용하면 AJAX 비동기 통신을 구현할 수 있다.
- 자체적으로 Promise 객체를 반환한다.

## Promise

- 전통적으로 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백함수를 사용한다. 그런데 이런 콜백 패턴은 콜백 헬로인해 가독성이 나쁘고, 에러의 처리가 곤란하여 ES6부터 비동기 처리를 위한 Promise가 도입됬다.
- Promise 비동기처리 성공 -> resolve 메소드 호출 -> 비동기 처리 결과를 후속처리메서드로 전달
- Promise 비동기처리 실패 -> reject 메소드 호출 -> 에러 메시지를 후속 처리 메서드로 전달
- 후속처리 메서드에는 then과 catch가 있으며 모두 Promise를 반환한다. then으로 메소드 체이닝을 통해 콜백 헬 문제를 해결한다.
- Promise는 state와 result 2가지의 숨김 프로퍼티를 갖고있다.
  - result: resolve가 호출되면 value가 되며 reject가 호출되면 error를 갖는다.
  - state
    - pending: 이행,거부 하지 않은 초기 상태
    - fulfilled: 연산이 성공적으로완료됨
    - rejected: 연산이 실패함

## Async / Await

- ES8의 공식 스펙으로 비교적 최근에 정의된 문법
- 비교적 쉽고 명확하게 코드 작성 가능
- async 키워드를 붙히면 항상 Promise를 반환하다.
- 자바스크립트는 await 키워드를 만나면 프로미스가 처리될 때까지 기다린다.
  이후 후속 처리되노 결과 값이 반환되며, then catch를 쓰지 않아도 된다.
- 에러처리는 try, catch문으로 가능하다.

## 자바스크립트의 배열은 배열이 아니다.

- 자바스크립트의 배열은 배열이 아닌 객체이다. 더 정확하게는 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.
- 자바스크립트 배열 특징
  - 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느리다.
  - 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우 일반적인 배열보다 빠르다.
